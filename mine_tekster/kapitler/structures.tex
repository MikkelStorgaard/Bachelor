\section{Structures}
\label{sec:structures}
\textbf{Introduction to structures:}
\label{subsec:structuresaregood}
Without structures, every function and type in futhark shares the same scope.
Implementing modules lets us create functions that are alike, but keeps
distinctions between them.
Take this example of a program with two different vector types:

\begin{verbatim}
type vec3 = {f32, f32, f32}
type vec4 = {f32, f32, f32, f32}

fun vec3 vec3_plus(vec3 {a_1, ... , a_3}, vec3 {b_1, ..., b_3}) =
  {a_1 + b_1, ... , a_3 + b_3}

fun vec4 vec4_plus(vec4 {a_1, ... , a_4}, vec4 {b_1, ..., b_4}) =
  {a_1 + b_1, ... , a_4 + b_4}
\end{verbatim}

Let us try compartmentalizing a vector type and its functions into a structure.
In the following example, we have defined two different modules, each
containing a structure,
and a futhark program which includes and utilizes these modules:
\begin{verbatim}
Vec3Float.fut:
  structure Vec3Float = 
    struct
      type vector = {f32, f32, f32}
      fun vector plus( ... ) = ...
      fun vector minus( ... ) = ...
      fun vector multiply ( ... ) = ...
    end

Vec4Float.fut:
  structure Vec4Float = 
    struct
      type vector = {f32, f32, f32, f32}
      fun vector plus( ... ) = ...
      fun vector minus( ... ) = ...
      fun vector multiply ( ... ) = ...
    end
  
myprogram.fut:

  include Vec3Float
  include Vec4Float

  type vec3 = Vec3Float.vector
  type vec4 = Vec4Float.vector
  
  fun vec4 foo(vec3 vector) = 
    let {a, b, c} = Vec3.plus(vector, vector)
    in Vec4.multiply({a, b, c, 1.0f} , 4.0f)
\end{verbatim}

Whilst it \textit{is} possible to create libraries without a module
implementation \footnote{By including libraries that adds functions to the top
  level environment}, the user runs a risk of running into errors like
\texttt{MulipleDefinitionError}\footnote{Multiple functions of same name
  defined}, if any of the library functions uses any of the names, that the
local user is using as well.

An obvious use case is including a library of standard modules with the Futhark
language, as the ones displayed in other languages like Standard
ML\cite{sml_standard_lib} or Python\cite{python3_docs}.

The module system removes this hazard, as application of functions and types are
done using \textbf{longnames}, which adds prefixes to names. This way, functions
can have the same name, as long as they do not share the same prefix.

\begin{tcolorbox}
\textbf{Longnames:}\\
A longname consists of any amount of prefixes followed by a dot, followed by the
string id of the desired function or type.

In Futhark we will be using string ids for declarations, and longnames for
the accessing types and functions in structures.
\end{tcolorbox}

%% mere her
%% this is elaborated on during the scope

\subsection{Accessing types and functions within structures}

To work with type aliases and modules, we need to define the internal
environment of Futhark during compile time.

Before starting this project, the environment of Futhark could be described like
this:
\equation{$\Gamma = Functions$}, where $Functions : \{ Function : (strid,
  ArgTypes, RetType) \}$ where both ArgTypes and RetTypes they
have types $Type$, which is any type as defined in
\ref{initialtypegrammar}.\\

It is the goal of this project to expand the environment of Futhark, so that
\equation{$\Gamma = (Functions, TypeAliases, Signatures, Structures)$}.

TypeAliases, Signatures and Structures are described in their respective
sections. A structure can be regarded as a structure name, a reference to the
current total environment and an environment contained in the structure, so that
$Structure_{strid} = (strid, \Gamma,  \Gamma_{strid})$. Any $\Gamma_{strid}$
contains its own functions, typealiases, signatures and structures.\\
\\
$Gamma_{env}$ refers to the global environment at the given point in program
parsing.
$Gamma_{local}$ refers to the environment, that we are currently working in.



\subsection{Interference rules}
Now that we can discern between the glocal environment, and any number of
environments in structures, we must redefine the environment behaviour of Futhark at compile time.
\\
\\
If a function definition is defined as this:
\\
$fundef : fun RetType strid ArgTypes = Expressions$
\\ then adding a function to the Futhark environment follows the following rule:
\begin{prooftree}
  \AxiomC{$\Gamma_{local} \vdash fundef \Rightarrow \Gamma_{local}'$}
    \UnaryInfC{$\Gamma_{local} \vdash fundef_{strid} \Rightarrow \Gamma_{local} \oplus
      fundef_{strid} \Rightarrow \Gamma_{local}' $ }
\end{prooftree}
  \\
where $fundef_{name} \oplus \Gamma_{local} = \Gamma_{local} := (Functions_{\Gamma_{local}} \cup {\strid \to
  fundef \})$
  iff the function the function body is otherwise well-formed\footnote[]{I will not go further into
    the functionality of functions, as it is not within scope of this project.}.

After expanding the environment to contain the three new elements, we can define the
addition of any of these three elements follow the following rule:

\begin{prooftree}
  \AxiomC{ $\Gamma_{local} \vdash typedecl \Rightarrow \Gamma_{local} ' $ }
    \UnaryInfC{ $\Gamma_{local} \vdash$ \texttt{type} \textit{strid }\texttt{=}
      \textit{Type} $\RightArrow$ $\{ strid \to Type \} \oplus \Gamma_{local} \Rightarrow
      \Gamma_{local}'
      \}$ }
\end{prooftree} where $\{ strid \to Type \} \oplus \Gamma = \Gamma :=
Types_{\Gamma} \cup \{strid \to Type\}$ as defined in
\ref{typealiasinterference}.

The operations $structure_{strid} \oplus \Gamma_{local}$ and $signature_{strid} \oplus \Gamma_{local}$ are defined similarly to $fundef_{name} \oplus \Gamma$.


\subsection{Interference rules for structure definitions}
We must take a closer look at what happens, when a structure is defined:
The definition of a structure in Futhark has the following behaviour:\label{structure_rule}
\begin{prooftree}
  \AxiomC{ $\Gamma_{local} \vdash structdef_{strid} \Rightarrow \Gamma_{local}'$ }
  \AxiomC{ $\{ structdef_{strid} \to structdecls_{strid} \}$ }
    \BinaryInfC{$\Gamma_{local} \vdash$ \texttt{struct} \textit{strid}
      \texttt{=} \textit{declarations} \textit{end} \\
      $\Rightarrow$ \\
      $\Gamma_{strid} = \Gamma_{local} \oplus structdecls_{strid};$ \\
      $\Gamma_{local}' = \Gamma_{strid} \oplus \Gamma_{local} $
    } 
  \end{prooftree}.

\begin{tcolorbox}
  \textbf{Rule about multiple declarations of same name in same local environment:}\\
  Building a structure from a list of \textit{structdecls} allows for several
  different declarations in the same environment of the same name, as long as
  it is different types of declarations:\\
  \\
  For $decl : (name, type) , type \in \{Function, TypeAlias, Structure, Signature \}$:
  \begin{prooftree}
    \AxiomC{$\Gamma_{local} \vdash (decl ::\footnote{this is the list
        constructor operator} decls) \Rightarrow \Gamma_{local}'$ }
    \UnaryInfC{$\Gamma_{local} \vdash structdecl \Rightarrow structdecl \oplus \Gamma_{local} \Gamma_{local}'$
  \end{prooftree}
  where $decl (name, type) \oplus \Gamma_{local}$ adds the declaration to
  $\Gamma_{local}$ , iff $(name, type) \not\in decls$.
\end{tcolorbox}

where $\Gamma_{local} \oplus structdecls_{strid}$ builds an environment
$\Gamma_{strid}$, from $structdecls_{strid}$ interpreted in the environment
$\Gamma_{local}$. If $structdecls_{strid}$ contains a new function, type or
structure, with a name that is already used in $\Gamma_{local}$, the fun- or
type definition in $\Gamma_{strid}$ is will be the defined in $structdecls_{strid}$
\\
\\
and
$\Gamma_{strid} \oplus \Gamma_{local} = Structures_{\Gamma_{local}} := Structures_{\Gamma_{local}} \cup {strid \to \Gamma_{strid}}$ .\\
Please note, that $\Gamma_{local}$ does not have a reference
 $Structure\{strid \to \Gamma_{strid}}$, until the entire structure
  $structdef_{strid}$ has been parsed.

Interference rules for interpreting function and type declarations are
described below\ref{interpretingfunctionsandtypeswithstructures}.

\subsection{Interference rules for interpreting functions and types in an
  environment with structures}\label{interpretingfunctionsandtypeswithstructures}
There are three cases where it is necessary to resolve a function or a type from a
longname:\\

1) When applying a function as an expression in a function expression; i.e.
\begin{verbatim}
  let myNumber = Constants.numberFour()
\end{verbatim}

2) When using a function as an argument in a currying function; i.e.
\begin{verbatim}
  let numbers = [1, 2, 3, 4] in
  let sum = reduce(MathLib.plus , 0 , numbers)
\end{verbatim}

3) When using a type definition from a structure; i.e.
\begin{verbatim}
  type int_pair = Pairs.Int.t 
\end{verbatim}

%% MERE BEDRE OM VARIABLE SHADOWING


We can define the interference rule for using a longname in the three different
cases. As all three cases handles resolving a longname the same way, the rule
will only be called for the first case:

\begin{prooftree}
  \AxiomC{$(\Gamma_{local}, \Gamma_{env}) \vdash \mathit{longname} \Rightarrow \mathtt{apply} \mathit{function} $}
  \UnaryInfC{$(\Gamma_{local}, \Gamma_{env}) \vdash let x = longname()
    \Rightarrow x := \downarrow longname$}
\end{prooftree}

where
\begin{align*}
  \downarrow longname & = & \mathtt{if longname is defined in }\Gamma_{local} \\
                      &   & \mathtt{  then return getFromEnv(longname, }\Gamma_{local}) \\
                      &   & \mathtt{else return getFromEnv(longname, }\Gamma_{env})
\end{align*}.

There is not defined behaviour for the case where a longname is called, that is
defined in neither the local or global environment.
\subsubsection{Chunk-wise parsing of the Futhark program}
The declarations in a Futhark program are type checked and added to the internal program in
chunks.
These chunks are divided by structure declarations.

\begin{figure}
  \begin{verbatim}
    type foo = M0.bar
    structure M0 =
      struct
        type bar = int
      end
  \end{verbatim}
  \caption{This is not allowed, because the compiler does not know about M0,
    when foo is type checked}
\end{figure}

\begin{figure}
  \begin{verbatim}
    structure M0 =
      struct
        type bar = int
      end
    type foo = M0.bar
  \end{verbatim}
  \caption{This is allowed, because the compiler has already checked M0,
    when foo is being type checked}
\end{figure}

A structure is not added to the current environment, before it has been parsed
completely:
\begin{figure}
  \begin{verbatim}
  structure M0 =
    struct
      type foo = int
      type bar = M0.foo
    end
  \end{verbatim}
\end{figure}
The code above will return an \texttt{UndefinedStructure} error, as M0 has not
been added to the environment when bar is attempted to be resolved}

If the compiler encounters a reference to a value that has not yet been defined
in the local environment, it will attempt to resolve the reference in the
toplevel environment.

Look at the following example:


\subsection{Module access and variable shadowing}

Comments:
\begin{itemize}
  \item 2-4: It is allowed to use the same idenfitier several times in a
    program, as long as they are not used for the same construction; i.e.
    \begin{verbatim}
      type foo = ...
      fun f32 foo = ...
    \end{verbatim} is allowed, as functions and types are not read to the same
    table internally during compilation.
  \end{itemize}

