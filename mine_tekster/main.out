\BOOKMARK [1][-]{section.1}{Introduction}{}% 1
\BOOKMARK [2][-]{subsection.1.1}{Motivation}{section.1}% 2
\BOOKMARK [3][-]{subsubsection.1.1.1}{Abstraction increases readability.}{subsection.1.1}% 3
\BOOKMARK [3][-]{subsubsection.1.1.2}{Compartmentalization of functionality increases usability:}{subsection.1.1}% 4
\BOOKMARK [3][-]{subsubsection.1.1.3}{Approximating higher order functionality whilst keeping performance}{subsection.1.1}% 5
\BOOKMARK [2][-]{subsection.1.2}{Problem definition}{section.1}% 6
\BOOKMARK [3][-]{subsubsection.1.2.1}{Scope of project}{subsection.1.2}% 7
\BOOKMARK [2][-]{subsection.1.3}{Related work}{section.1}% 8
\BOOKMARK [1][-]{section.2}{Type aliases}{}% 9
\BOOKMARK [2][-]{subsection.2.1}{The language}{section.2}% 10
\BOOKMARK [3][-]{subsubsection.2.1.1}{Interference rules}{subsection.2.1}% 11
\BOOKMARK [2][-]{subsection.2.2}{Implementation}{section.2}% 12
\BOOKMARK [2][-]{subsection.2.3}{Parsing a type alias}{section.2}% 13
\BOOKMARK [3][-]{subsubsection.2.3.1}{Data types for describing a type}{subsection.2.3}% 14
\BOOKMARK [3][-]{subsubsection.2.3.2}{Adding resolved types to scope}{subsection.2.3}% 15
\BOOKMARK [3][-]{subsubsection.2.3.3}{Converting UserType to TypeBase}{subsection.2.3}% 16
\BOOKMARK [3][-]{subsubsection.2.3.4}{Why we added UserType instead of extending TypeBase}{subsection.2.3}% 17
\BOOKMARK [3][-]{subsubsection.2.3.5}{The slip from type aliases to realized types}{subsection.2.3}% 18
\BOOKMARK [2][-]{subsection.2.4}{Results}{section.2}% 19
\BOOKMARK [3][-]{subsubsection.2.4.1}{A type cannot be defined twice in the same environment}{subsection.2.4}% 20
\BOOKMARK [3][-]{subsubsection.2.4.2}{A type alias cannot be defined, if it refers to a type alias that has not been defined}{subsection.2.4}% 21
\BOOKMARK [3][-]{subsubsection.2.4.3}{A type alias cannot be cyclically defined}{subsection.2.4}% 22
\BOOKMARK [3][-]{subsubsection.2.4.4}{Example of planet simulations being simplified by type aliases}{subsection.2.4}% 23
\BOOKMARK [2][-]{subsection.2.5}{Future work}{section.2}% 24
\BOOKMARK [1][-]{section.3}{Structures}{}% 25
\BOOKMARK [2][-]{subsubsection.3.0.1}{Accessing types and functions within structures}{section.3}% 26
\BOOKMARK [2][-]{subsection.3.1}{Interference rules}{section.3}% 27
\BOOKMARK [3][-]{subsubsection.3.1.1}{Interference rules for adding multiple declarations}{subsection.3.1}% 28
\BOOKMARK [3][-]{subsubsection.3.1.2}{Rule for adding a structure to the local environment}{subsection.3.1}% 29
\BOOKMARK [3][-]{subsubsection.3.1.3}{Interference rules for interpreting functions and types in an environment with structures}{subsection.3.1}% 30
\BOOKMARK [2][-]{subsection.3.2}{Implementation}{section.3}% 31
\BOOKMARK [3][-]{subsubsection.3.2.1}{The Scope datatype}{subsection.3.2}% 32
\BOOKMARK [3][-]{subsubsection.3.2.2}{checkProg}{subsection.3.2}% 33
\BOOKMARK [3][-]{subsubsection.3.2.3}{Checking for duplicates}{subsection.3.2}% 34
\BOOKMARK [3][-]{subsubsection.3.2.4}{Dividing a Futhark program into chunks}{subsection.3.2}% 35
\BOOKMARK [3][-]{subsubsection.3.2.5}{Checking function- and type declarations }{subsection.3.2}% 36
\BOOKMARK [3][-]{subsubsection.3.2.6}{Checking structure declarations}{subsection.3.2}% 37
\BOOKMARK [3][-]{subsubsection.3.2.7}{Resolving the application of a longname}{subsection.3.2}% 38
\BOOKMARK [3][-]{subsubsection.3.2.8}{Including structures, functions and types from other files}{subsection.3.2}% 39
\BOOKMARK [3][-]{subsubsection.3.2.9}{Keeping track of function names}{subsection.3.2}% 40
\BOOKMARK [2][-]{subsection.3.3}{Tests}{section.3}% 41
\BOOKMARK [3][-]{subsubsection.3.3.1}{Testing rule for multiple declarations [...]}{subsection.3.3}% 42
\BOOKMARK [3][-]{subsubsection.3.3.2}{Testing structures can be called as expected}{subsection.3.3}% 43
\BOOKMARK [3][-]{subsubsection.3.3.3}{Testing rule for variable shadowing}{subsection.3.3}% 44
\BOOKMARK [2][-]{subsection.3.4}{Results}{section.3}% 45
\BOOKMARK [2][-]{subsection.3.5}{Future work}{section.3}% 46
\BOOKMARK [1][-]{section.4}{Signatures}{}% 47
\BOOKMARK [2][-]{subsection.4.1}{Purpose of module signatures}{section.4}% 48
\BOOKMARK [2][-]{subsection.4.2}{Implementation}{section.4}% 49
\BOOKMARK [2][-]{subsection.4.3}{Results}{section.4}% 50
\BOOKMARK [1][-]{section.5}{Functors}{}% 51
\BOOKMARK [2][-]{subsection.5.1}{The reason for functors}{section.5}% 52
\BOOKMARK [2][-]{subsection.5.2}{Tentative implementation of functors}{section.5}% 53
\BOOKMARK [1][-]{section.6}{Discussion of results}{}% 54
\BOOKMARK [2][-]{subsection.6.1}{Method}{section.6}% 55
\BOOKMARK [3][-]{subsubsection.6.1.1}{Alternatives to the chosen method}{subsection.6.1}% 56
\BOOKMARK [2][-]{subsection.6.2}{Conclusion}{section.6}% 57
\BOOKMARK [2][-]{subsection.6.3}{Acknowledgements}{section.6}% 58
\BOOKMARK [1][-]{section.7}{Appendices}{}% 59
\BOOKMARK [2][-]{subsection.7.1}{Futhark Module Language}{section.7}% 60
\BOOKMARK [2][-]{subsection.7.2}{nbody before type aliasing}{section.7}% 61
\BOOKMARK [2][-]{subsection.7.3}{nbody using type aliasing}{section.7}% 62
\BOOKMARK [1][-]{section.8}{References}{}% 63
