\section{Structures}
\label{sec:structures}
\textbf{Introduction to structures:}
\label{subsec:structuresaregood}
Without structures, every function and type in futhark shares the same scope.
Implementing modules lets us create functions that are alike, but keeps
distinctions between them.
Take this example of a program with two different vector types:

\begin{verbatim}
type vec3 = {f32, f32, f32}
type vec4 = {f32, f32, f32, f32}

fun vec3 vec3_plus(vec3 {a_1, ... , a_3}, vec3 {b_1, ..., b_3}) =
  {a_1 + b_1, ... , a_3 + b_3}

fun vec4 vec4_plus(vec4 {a_1, ... , a_4}, vec4 {b_1, ..., b_4}) =
  {a_1 + b_1, ... , a_4 + b_4}
\end{verbatim}

Let us try compartmentalizing a vector type and its functions into a structure.
In the following example, we have defined two different modules, each
containing a structure,
and a futhark program which includes and utilizes these modules:
\begin{verbatim}
Vec3Float.fut:
  structure Vec3Float = 
    struct
      type vector = {f32, f32, f32}
      fun vector plus( ... ) = ...
      fun vector minus( ... ) = ...
      fun vector multiply ( ... ) = ...
    end

Vec4Float.fut:
  structure Vec4Float = 
    struct
      type vector = {f32, f32, f32, f32}
      fun vector plus( ... ) = ...
      fun vector minus( ... ) = ...
      fun vector multiply ( ... ) = ...
    end
  
myprogram.fut:

  include Vec3Float
  include Vec4Float

  type vec3 = Vec3Float.vector
  type vec4 = Vec4Float.vector
  
  fun vec4 foo(vec3 vector) = 
    let {a, b, c} = Vec3.plus(vector, vector)
    in Vec4.multiply({a, b, c, 1.0f} , 4.0f)
\end{verbatim}

Whilst it \textit{is} possible to create libraries without a module
implementation \footnote{By including libraries that adds functions to the top
  level environment}, the user runs a risk of running into errors like
\texttt{MulipleDefinitionError}\footnote{Multiple functions of same name
  defined}, if any of the library functions uses any of the names, that the
local user is using as well.

The module system removes this hazard, as names from an imported module
\texttt{Foo} are accessed through its \textbf{longname}, as shown in function
\texttt{foo} in the example above.
\\
A longname consists of any amount of prefixes followed by a dot, followed by the
name of the desired function or type.

An obvious use case is including a library of standard modules with the Futhark
language, as the ones displayed in other languages like Standard
ML\cite{sml_standard_lib} or Python\cite{python3_docs}.

%% mere her
%% this is elaborated on during the scope

\subsection{Accessing types and functions within structures}
The structures implemented in this project uses variable shadowing.
When a new structure is defined, \textit{variable shadowing} grants this
structure access to all previously defined functions, types and modules up until
the definition of this structure.\\

Accessing types and functions are necessary in two cases: when retrieving a type
definition from a structure, and when using an
\textit{Apply}-expression\footnote{An Apply-expression is the application of a
  function, i.e \texttt{foo(a,b)} in \texttt{let result = foo(a,b) }} in a
Futhark program.

\subsection{Working with the Futhark environment}

To work with type aliases and modules, we need to define the internal
environment of Futhark during compile time.

Before starting this project, the environment of Futhark could be described like
this:
\equation{$\Gamma = Functions$}, where $Functions : \{ Function : (strid,
  ArgTypes, RetType) \}$ where both ArgTypes and RetTypes they
have types $Type$, which is any type as defined in
\ref{initialtypegrammar}.\\

It is the goal of this project to expand the environment of Futhark, so that
\equation{$\Gamma = (Functions, TypeAliases, Signatures, Structures)$}.

TypeAliases, Signatures and Structures are described in their respective
sections. A structure can be regarded as a structure name, a reference to the
current total environment and an environment contained in the structure, so that
$Structure_{strid} = (strid, \Gamma,  \Gamma_{strid})$. Any $\Gamma_{strid}$
contains its own functions, typealiases, signatures and structures.\\
\\
$Gamma_{env}$ refers to the global environment at the given point in program
parsing.
$Gamma_{local}$ refers to the environment, that we are currently working in.

\subsection{Interference rules}
Now that we can discern between the glocal environment, and any number of
environments in structures, we must redefine the environment behaviour of Futhark at compile time.
\\
\\
If a function definition is defined as this:
\\
$fundef : fun RetType strid ArgTypes = Expressions$
\\ then adding a function to the Futhark environment follows the following rule:
\begin{prooftree}
  \AxiomC{$\Gamma_{local} \vdash fundef \Rightarrow \Gamma_{local}'$}
    \UnaryInfC{$\Gamma_{local} \vdash fundef_{strid} \Rightarrow \Gamma_{local} \oplus
      fundef_{strid} \Rightarrow \Gamma_{local}' $ }
\end{prooftree}
  \\
where $fundef_{name} \oplus \Gamma_{local} = \Gamma_{local} := (Functions_{\Gamma_{local}} \cup {\strid \to
  fundef \})$
  iff the function is not already defined in $\Gamma_{local}$, and the
  function body is otherwise well-formed\footnote[]{I will not go further into
    the functionality of functions, as it is not within scope of this project.}.

After expanding the environment to contain the three new elements, we can define the
addition of any of these three elements follow the following rule:

\begin{prooftree}
  \AxiomC{ $\Gamma_{local} \vdash typedecl \Rightarrow \Gamma_{local} ' $ }
    \UnaryInfC{ $\Gamma_{local} \vdash$ \texttt{type} \textit{strid }\texttt{=}
      \textit{Type} $\RightArrow$ $\{ strid \to Type \} \oplus \Gamma_{local} \Rightarrow
      \Gamma_{local}'
      \}$ }
\end{prooftree} where $\{ strid \to Type \} \oplus \Gamma = \Gamma :=
Types_{\Gamma} \cup \{strid \to Type\}$ as defined in
\ref{typealiasinterference}.

The operations $structure_{strid} \oplus \Gamma_{local}$ and $signature_{strid} \oplus \Gamma_{local}$ are defined similarly to $fundef_{name} \oplus \Gamma$.

We must take a closer look at what happens, when a structure is defined:

\subsubsection{Interference rules for structure definitions}
Defining a 
\begin{prooftree}
  \AxiomC{ $\Gamma_{local} \vdash structdef_{strid} \Rightarrow \Gamma_{local}'$ }
  \AxiomC{ $\{ structdef_{strid} \to structdecls_{strid} \}$}
    \BinaryInfC{$\Gamma_{local} \vdash$ \texttt{struct} \textit{strid}
      \texttt{=} \textit{declarations} \textit{end}
      $\Rightarrow$
      $\Gamma_{strid} = \Gamma_{local} \oplus structdecls_{strid};$ \\
      $\Gamma_{local}' = \Gamma_{strid} \oplus \Gamma_{local} $  } 
\end{prooftree}

where $\Gamma_{local} \oplus structdecls_{strid}$ builds an environment
$\Gamma_{strid}$, from $structdecls_{strid}$ interpreted in the environment
$\Gamma_{local}$.
\\
\\
and $\Gamma_{strid} \oplus \Gamma_{local} = Structures_{\Gamma_{local}} :=
Structures_{\Gamma_{local}} \cup {strid \to \Gamma_{strid}}$


Interference rules for interpreting function and type declarations are
described below\ref{interpretingfunctionsandtypeswithstructures}.

\subsubsection{Environmental placement of a nested structure}
As structures can contain other structures, we must define where an arbritrarily deep nested
structure is placed in its nests.
\begin{figure}
  \label{arbitrarilynestedstructure}
  \begin{verbatim}
    structure M0 =
      struct
        structure M1 =
          struct
           ..
            ..
             structure Mn =
               struct
                 fun int four() = 4
               end
          end
       end
     end
  \end{verbatim}
\caption{An arbitrarily deeply nested structure}
\end{figure}
To apply function \texttt{four()} in $M_n$ in
figure\ref{arbitrarilynestedstructure}, we must access it using a longname.

\texttt{fun eight() = 2 * M0.M1. ... .Mn.four()}


\begin{prooftree}
  \AxiomC{$\Gamma_{env} \vdash$ \texttt{funexp} containing a function application $\Rightarrow$ \texttt{exp}}  }
  \AxiomC{$structure_{M_n} \in structure\_{...} \in structure_{M_0} \in \Gamma_{env}$}
  \AxiomC{$four() \in Functions_{\Gamma_{M_n}}$}
    \TrinaryInfC{$\Gamma_{env} \vdash$ \texttt{exp} $\oplus$ \texttt{M0.M1. ...
        .Mn.four()} $\Rightarrow$ \texttt{exp} $\oplus$ \texttt{four()}\textsubscript{$M_n$}} 
\end{prooftree}

where $\oplus$ is any operation between two expressions in a Futhark function.

\subsection{Interference rules for structure definitions}
\begin{prooftree}
  \AxiomC{ $\Gamma \vdash structure_{strid}$ }
  \AxiomC{ $structure_{strid} \Rightarrow (strid, \Gamma, \Gamma_{strid})$}
    \BinaryInfC{$\Gamma \vdash$ struct strid = declarations $\Rightarrow
      \Gamma_{strid} = \Gamma \oplus declarations_{strid}; \Gamma_{strid} \oplus \Gamma \Rightarrow \Gamma' $  } 
\end{prooftree}

where $\Gamma \oplus declarations_{strid}$ builds an environment
$\Gamma_{strid}$, from $declarations_{strid}$ interpreted in the environment
$\Gamma$. Interference rules for interpreting function and type declarations are
described below\ref{interpretingfunctionsandtypeswithstructures}.

\subsection{Interference rules for interpreting functions and types in an
  environment with structures}\label{interpretingfunctionsandtypeswithstructures}
To be 

%% \oplus if longname is defined in \gamma_local then longname \oplus \Gamma_local
%%          else longname \oplus \Gamma        


\subsubsection{Chunk-wise parsing of the Futhark program}
The declarations in a Futhark program are type checked and added to the internal program in
chunks.
These chunks are divided by structure declarations.

\begin{figure}
  \begin{verbatim}
    type foo = M0.bar
    structure M0 =
      struct
        type bar = int
      end
  \end{verbatim}
  \caption{This is not allowed, because the compiler does not know about M0,
    when foo is type checked}
\end{figure}

\begin{figure}
  \begin{verbatim}
    structure M0 =
      struct
        type bar = int
      end
    type foo = M0.bar
  \end{verbatim}
  \caption{This is allowed, because the compiler has already checked M0,
    when foo is being type checked}
\end{figure}

A structure is not added to the current environment, before it has been parsed
completely:
\begin{figure}
  \begin{verbatim}
  structure M0 =
    struct
      type foo = int
      type bar = M0.foo
    end
  \end{verbatim}
\end{figure}
The code above will return an \texttt{UndefinedStructure} error, as M0 has not
been added to the environment when bar is attempted to be resolved}

If the compiler encounters a reference to a value that has not yet been defined
in the local environment, it will attempt to resolve the reference in the
toplevel environment.

Look at the following example:

\begin{figure}
\begin{verbatim}
structure M0 =
  struct
    type foo = f32
  end

structure M1 =
  type bar = M0.foo
  structure M0 =
    struct
      type foo = int
    end
  type baz = M0.foo
  end
\end{verbatim}
  \caption{The identifier M0 can refer to two different structures}
\end{figure}
Type \texttt{bar} has the type \texttt{f32}, whilst \texttt{baz} has the type
\texttt{int}.
This is because \texttt{bar} does not know about \texttt{M1s} nested structure
\texttt{M0}, as opposed to \texttt{baz}, which does.

\begin{verbatim}
type foo = {int, f32}

structure M0 =
  struct
    type foo = foo -- the type is defined from l. 1
    type bar = f32
  end

structure M1 =
  struct
    type foo = f32
    type bar = M0.bar -- type is defined from l.6

    structure M0 =
      struct
        type foo = M0.foo -- is defined at l. 5
        type bar = {int, int, int}
      end

    type baz = M0.bar -- defined at line 17
  end

type baz = M1.bar -- is defined at l. 13
\end{verbatim}

\subsection{Module access and variable shadowing}

Comments:
\begin{itemize}
  \item 2-4: It is allowed to use the same idenfitier several times in a
    program, as long as they are not used for the same construction; i.e.
    \begin{verbatim}
      type foo = ...
      fun f32 foo = ...
    \end{verbatim} is allowed, as functions and types are not read to the same
    table internally during compilation.
  \end{itemize}

